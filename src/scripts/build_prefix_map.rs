use std::collections::BTreeMap;
use std::fs;
use std::path::Path;
use tokenaisu::moses::Language;

#[derive(Debug, PartialEq)]
enum PrefixEntry {
    Always,
    NumericOnly,
    Comment,
}

fn main() -> std::io::Result<()> {
    let src_dir = Path::new("src/nonbreaking_prefixes");
    let mut map: BTreeMap<String, Vec<(String, PrefixEntry)>> = BTreeMap::new();

    // Parse original text file and store results in per language in a BTree (so that they are sorted in alphabetical order)
    for entry in fs::read_dir(src_dir)? {
        let p = entry?.path();
        if p.is_file()
            && p.file_name()
                .unwrap()
                .to_str()
                .unwrap()
                .starts_with("nonbreaking_prefix.")
        {
            let language = p.extension().and_then(|s| s.to_str());
            let contents = fs::read_to_string(&p)?;
            for line in contents.lines() {
                let line = line.trim();
                if line.is_empty() {
                    continue;
                }
                let (prefix, ptype) = if let Some(pos) = line.find('#') {
                    let (t, comment) = line.split_at(pos);
                    let t = t.trim_end();
                    if line.starts_with('#') {
                        (comment[1..].to_string(), PrefixEntry::Comment)
                    } else if comment.contains("NUMERIC_ONLY") {
                        (t.to_string(), PrefixEntry::NumericOnly)
                    } else {
                        (line.to_string(), PrefixEntry::Always)
                    }
                } else {
                    (line.to_string(), PrefixEntry::Always)
                };
                map.entry(language.unwrap().to_owned())
                    .or_default()
                    .push((prefix, ptype));
            }
        }
    }

    // Generate Rust source code
    let mut out = String::from(
"// @generated by bin/build_prefix_map.rs using the non-breaking prefixes files from https://github.com/moses-smt/mosesdecoder/tree/master/scripts/share/nonbreaking_prefixes
use std::sync::LazyLock;
use std::collections::HashMap;

#[derive(Debug, PartialEq)]
pub enum PrefixType {
    Always,  
    NumericOnly,
}

pub static NONBREAKING_PREFIXES: LazyLock<HashMap<&'static str, HashMap<&'static str, PrefixType>>> = LazyLock::new(|| {
    let mut m = HashMap::new();\n",
    );

    for (lang, entries) in &map {
        out.push_str(&format!(
            "    m.insert(\n        // Non-breaking prefixes and original comments extracted from https://github.com/moses-smt/mosesdecoder/tree/master/scripts/share/nonbreaking_prefixes/nonbreaking_prefix.{lang}\n        \"{lang}\",\n        HashMap::from([\n",
            lang = lang
        ));
        for (prefix, ptype) in entries {
            match ptype {
                PrefixEntry::Comment => {
                    out.push_str(&format!("            // {}\n", prefix));
                }
                PrefixEntry::Always | PrefixEntry::NumericOnly => {
                    let ty = match ptype {
                        PrefixEntry::Always => "PrefixType::Always",
                        PrefixEntry::NumericOnly => "PrefixType::NumericOnly",
                        _ => "",
                    };
                    // Escape prefix if needed
                    let esc = prefix.replace("\\", "\\\\").replace("\"", "\\\"");
                    out.push_str(&format!("            (\"{}\", {}),\n", esc, ty));
                }
            }
        }
        out.push_str("        ]),\n    );\n");
    }

    out.push_str("\n    m\n});");

    println!("{}", out);
    Ok(())
}
